/**
 * @file        claTasks.cla
 * @project		06_adcEpwmSoc_dclClaPid
 * 
 * @date        3 Jun 2017
 * @author      Manuel Del Basso (mainster)
 * @email       manuel.delbasso@gmail.com
 *
 * @ide         Code Composer Studio Version: 7.1.0.00015 
 * @license		GNU GPL v3
 * 
 * @brief       TODO
 * 
 @verbatim

 ------------------------------------------------------------------------

 Copyright (C) 2017  Manuel Del Basso

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 ------------------------------------------------------------------------

 @endverbatim
 *
 */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Includes  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~  Private typedefs  ~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~  Private macro definitions  ~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~  Private variable declaration  ~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~  Private function prototypes  ~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~  Private function implementations  ~~~~~~~~~~~~~~~~~~ */

#include "cla_shared.h"

//!< Globals (Variables global to all CLA tasks only)

__interrupt void CLA1_PID1_calc(void) {
	__mdebugstop();

	//!< Read feedback signal.
//	pid1.mk = ((float) AdcaResultRegs.ADCRESULT0 - 2048.0f) / 2047.0f;
	//!< Read set-point signal.
//	pid1.rk = (float) AdcaResultRegs.ADCRESULT1;
	//!< No external clamping is used for know.
	pid1.lk = 0.0f;

	//!< External clamp for anti-windup reset
	DCL_runClamp_C1(&pid1.lk, 1.0f, 0.0f);

	//!< Run PID controller
	pid1.uk = DCL_runPID_C4(&(pid1.param), pid1.rk, pid1.mk, pid1.lk);

	//!< Update DACx output register value.
//	DacaRegs.DACVALS.all = (uint16_t) ((pid1.uk / 2.0f + .5f) * 4095.0f);

	//	// write u(k) to PWM
//	Duty = (uk / 2.0f + 0.5f) * (float) EPwm1Regs.TBPRD;
//	EPwm1Regs.CMPA.all  = (Uint16) Duty;

//	IsrCount++;
}

__interrupt void Cla1Task2(void) { }
__interrupt void Cla1Task3(void) { }
__interrupt void Cla1Task4(void) { }
__interrupt void Cla1Task5(void) { }
__interrupt void Cla1Task6(void) { }
__interrupt void Cla1Task7(void) { }
__interrupt void Cla1Task8(void) {

}
